// Code generated by protoc-gen-go-psm. DO NOT EDIT.

package realm_j5pb

import (
	context "context"
	fmt "fmt"
	psm_j5pb "github.com/pentops/j5/gen/j5/state/v1/psm_j5pb"
	psm "github.com/pentops/protostate/psm"
	sqrlx "github.com/pentops/sqrlx.go/sqrlx"
)

// PSM TenantPSM

type TenantPSM = psm.StateMachine[
	*TenantKeys,    // implements psm.IKeyset
	*TenantState,   // implements psm.IState
	TenantStatus,   // implements psm.IStatusEnum
	*TenantData,    // implements psm.IStateData
	*TenantEvent,   // implements psm.IEvent
	TenantPSMEvent, // implements psm.IInnerEvent
]

type TenantPSMDB = psm.DBStateMachine[
	*TenantKeys,    // implements psm.IKeyset
	*TenantState,   // implements psm.IState
	TenantStatus,   // implements psm.IStatusEnum
	*TenantData,    // implements psm.IStateData
	*TenantEvent,   // implements psm.IEvent
	TenantPSMEvent, // implements psm.IInnerEvent
]

type TenantPSMEventSpec = psm.EventSpec[
	*TenantKeys,    // implements psm.IKeyset
	*TenantState,   // implements psm.IState
	TenantStatus,   // implements psm.IStatusEnum
	*TenantData,    // implements psm.IStateData
	*TenantEvent,   // implements psm.IEvent
	TenantPSMEvent, // implements psm.IInnerEvent
]

type TenantPSMHookBaton = psm.HookBaton[
	*TenantKeys,    // implements psm.IKeyset
	*TenantState,   // implements psm.IState
	TenantStatus,   // implements psm.IStatusEnum
	*TenantData,    // implements psm.IStateData
	*TenantEvent,   // implements psm.IEvent
	TenantPSMEvent, // implements psm.IInnerEvent
]

type TenantPSMFullBaton = psm.CallbackBaton[
	*TenantKeys,    // implements psm.IKeyset
	*TenantState,   // implements psm.IState
	TenantStatus,   // implements psm.IStatusEnum
	*TenantData,    // implements psm.IStateData
	*TenantEvent,   // implements psm.IEvent
	TenantPSMEvent, // implements psm.IInnerEvent
]

type TenantPSMEventKey = string

const (
	TenantPSMEventNil     TenantPSMEventKey = "<nil>"
	TenantPSMEventCreated TenantPSMEventKey = "created"
	TenantPSMEventUpdated TenantPSMEventKey = "updated"
)

// EXTEND TenantKeys with the psm.IKeyset interface

// PSMIsSet is a helper for != nil, which does not work with generic parameters
func (msg *TenantKeys) PSMIsSet() bool {
	return msg != nil
}

// PSMFullName returns the full name of state machine with package prefix
func (msg *TenantKeys) PSMFullName() string {
	return "j5.realm.v1.tenant"
}
func (msg *TenantKeys) PSMKeyValues() (map[string]string, error) {
	keyset := map[string]string{
		"tenant_id": msg.TenantId,
		"realm_id":  msg.RealmId,
	}
	if msg.TenantType != "" {
		keyset["tenant_type"] = msg.TenantType
	}
	return keyset, nil
}

// EXTEND TenantState with the psm.IState interface

// PSMIsSet is a helper for != nil, which does not work with generic parameters
func (msg *TenantState) PSMIsSet() bool {
	return msg != nil
}

func (msg *TenantState) PSMMetadata() *psm_j5pb.StateMetadata {
	if msg.Metadata == nil {
		msg.Metadata = &psm_j5pb.StateMetadata{}
	}
	return msg.Metadata
}

func (msg *TenantState) PSMKeys() *TenantKeys {
	return msg.Keys
}

func (msg *TenantState) SetStatus(status TenantStatus) {
	msg.Status = status
}

func (msg *TenantState) SetPSMKeys(inner *TenantKeys) {
	msg.Keys = inner
}

func (msg *TenantState) PSMData() *TenantData {
	if msg.Data == nil {
		msg.Data = &TenantData{}
	}
	return msg.Data
}

// EXTEND TenantData with the psm.IStateData interface

// PSMIsSet is a helper for != nil, which does not work with generic parameters
func (msg *TenantData) PSMIsSet() bool {
	return msg != nil
}

// EXTEND TenantEvent with the psm.IEvent interface

// PSMIsSet is a helper for != nil, which does not work with generic parameters
func (msg *TenantEvent) PSMIsSet() bool {
	return msg != nil
}

func (msg *TenantEvent) PSMMetadata() *psm_j5pb.EventMetadata {
	if msg.Metadata == nil {
		msg.Metadata = &psm_j5pb.EventMetadata{}
	}
	return msg.Metadata
}

func (msg *TenantEvent) PSMKeys() *TenantKeys {
	return msg.Keys
}

func (msg *TenantEvent) SetPSMKeys(inner *TenantKeys) {
	msg.Keys = inner
}

// PSMEventKey returns the TenantPSMEventPSMEventKey for the event, implementing psm.IEvent
func (msg *TenantEvent) PSMEventKey() TenantPSMEventKey {
	tt := msg.UnwrapPSMEvent()
	if tt == nil {
		return TenantPSMEventNil
	}
	return tt.PSMEventKey()
}

// UnwrapPSMEvent implements psm.IEvent, returning the inner event message
func (msg *TenantEvent) UnwrapPSMEvent() TenantPSMEvent {
	if msg == nil {
		return nil
	}
	if msg.Event == nil {
		return nil
	}
	switch v := msg.Event.Type.(type) {
	case *TenantEventType_Created_:
		return v.Created
	case *TenantEventType_Updated_:
		return v.Updated
	default:
		return nil
	}
}

// SetPSMEvent sets the inner event message from a concrete type, implementing psm.IEvent
func (msg *TenantEvent) SetPSMEvent(inner TenantPSMEvent) error {
	if msg.Event == nil {
		msg.Event = &TenantEventType{}
	}
	switch v := inner.(type) {
	case *TenantEventType_Created:
		msg.Event.Type = &TenantEventType_Created_{Created: v}
	case *TenantEventType_Updated:
		msg.Event.Type = &TenantEventType_Updated_{Updated: v}
	default:
		return fmt.Errorf("invalid type %T for TenantEventType", v)
	}
	return nil
}

type TenantPSMEvent interface {
	psm.IInnerEvent
	PSMEventKey() TenantPSMEventKey
}

// EXTEND TenantEventType_Created with the TenantPSMEvent interface

// PSMIsSet is a helper for != nil, which does not work with generic parameters
func (msg *TenantEventType_Created) PSMIsSet() bool {
	return msg != nil
}

func (*TenantEventType_Created) PSMEventKey() TenantPSMEventKey {
	return TenantPSMEventCreated
}

// EXTEND TenantEventType_Updated with the TenantPSMEvent interface

// PSMIsSet is a helper for != nil, which does not work with generic parameters
func (msg *TenantEventType_Updated) PSMIsSet() bool {
	return msg != nil
}

func (*TenantEventType_Updated) PSMEventKey() TenantPSMEventKey {
	return TenantPSMEventUpdated
}

func TenantPSMBuilder() *psm.StateMachineConfig[
	*TenantKeys,    // implements psm.IKeyset
	*TenantState,   // implements psm.IState
	TenantStatus,   // implements psm.IStatusEnum
	*TenantData,    // implements psm.IStateData
	*TenantEvent,   // implements psm.IEvent
	TenantPSMEvent, // implements psm.IInnerEvent
] {
	return &psm.StateMachineConfig[
		*TenantKeys,    // implements psm.IKeyset
		*TenantState,   // implements psm.IState
		TenantStatus,   // implements psm.IStatusEnum
		*TenantData,    // implements psm.IStateData
		*TenantEvent,   // implements psm.IEvent
		TenantPSMEvent, // implements psm.IInnerEvent
	]{}
}

// TenantPSMMutation runs at the start of a transition to merge the event information into the state data object. The state object is mutable in this context.
func TenantPSMMutation[SE TenantPSMEvent](cb func(*TenantData, SE) error) psm.TransitionMutation[
	*TenantKeys,    // implements psm.IKeyset
	*TenantState,   // implements psm.IState
	TenantStatus,   // implements psm.IStatusEnum
	*TenantData,    // implements psm.IStateData
	*TenantEvent,   // implements psm.IEvent
	TenantPSMEvent, // implements psm.IInnerEvent
	SE,             // Specific event type for the transition
] {
	return psm.TransitionMutation[
		*TenantKeys,    // implements psm.IKeyset
		*TenantState,   // implements psm.IState
		TenantStatus,   // implements psm.IStatusEnum
		*TenantData,    // implements psm.IStateData
		*TenantEvent,   // implements psm.IEvent
		TenantPSMEvent, // implements psm.IInnerEvent
		SE,             // Specific event type for the transition
	](cb)
}

// TenantPSMLogicHook runs after the mutation is complete. This hook can trigger side effects, including chained events, which are additional events processed by the state machine. Use this for Business Logic which determines the 'next step' in processing.
func TenantPSMLogicHook[
	SE TenantPSMEvent,
](
	cb func(
		context.Context,
		TenantPSMHookBaton,
		*TenantState,
		SE,
	) error) psm.TransitionHook[
	*TenantKeys,    // implements psm.IKeyset
	*TenantState,   // implements psm.IState
	TenantStatus,   // implements psm.IStatusEnum
	*TenantData,    // implements psm.IStateData
	*TenantEvent,   // implements psm.IEvent
	TenantPSMEvent, // implements psm.IInnerEvent
] {
	eventType := (*new(SE)).PSMEventKey()
	return psm.TransitionHook[
		*TenantKeys,    // implements psm.IKeyset
		*TenantState,   // implements psm.IState
		TenantStatus,   // implements psm.IStatusEnum
		*TenantData,    // implements psm.IStateData
		*TenantEvent,   // implements psm.IEvent
		TenantPSMEvent, // implements psm.IInnerEvent
	]{
		Callback: func(ctx context.Context, tx sqrlx.Transaction, baton TenantPSMFullBaton, state *TenantState, event *TenantEvent) error {
			asType, ok := any(event.UnwrapPSMEvent()).(SE)
			if !ok {
				name := event.ProtoReflect().Descriptor().FullName()
				return fmt.Errorf("unexpected event type in transition: %s [IE] does not match [SE] (%T)", name, new(SE))
			}
			return cb(ctx, baton, state, asType)
		},
		EventType:   eventType,
		RunOnFollow: false,
	}
}

// TenantPSMDataHook runs after the mutations, and can be used to update data in tables which are not controlled as the state machine, e.g. for pre-calculating fields for performance reasons. Use of this hook prevents (future) transaction optimizations, as the transaction state when the function is called must needs to match the processing state, but only for this single transition, unlike the GeneralEventDataHook.
func TenantPSMDataHook[
	SE TenantPSMEvent,
](
	cb func(
		context.Context,
		sqrlx.Transaction,
		*TenantData,
		SE,
	) error) psm.TransitionHook[
	*TenantKeys,    // implements psm.IKeyset
	*TenantState,   // implements psm.IState
	TenantStatus,   // implements psm.IStatusEnum
	*TenantData,    // implements psm.IStateData
	*TenantEvent,   // implements psm.IEvent
	TenantPSMEvent, // implements psm.IInnerEvent
] {
	eventType := (*new(SE)).PSMEventKey()
	return psm.TransitionHook[
		*TenantKeys,    // implements psm.IKeyset
		*TenantState,   // implements psm.IState
		TenantStatus,   // implements psm.IStatusEnum
		*TenantData,    // implements psm.IStateData
		*TenantEvent,   // implements psm.IEvent
		TenantPSMEvent, // implements psm.IInnerEvent
	]{
		Callback: func(ctx context.Context, tx sqrlx.Transaction, baton TenantPSMFullBaton, state *TenantState, event *TenantEvent) error {
			asType, ok := any(event.UnwrapPSMEvent()).(SE)
			if !ok {
				name := event.ProtoReflect().Descriptor().FullName()
				return fmt.Errorf("unexpected event type in transition: %s [IE] does not match [SE] (%T)", name, new(SE))
			}
			return cb(ctx, tx, state.PSMData(), asType)
		},
		EventType:   eventType,
		RunOnFollow: true,
	}
}

// TenantPSMLinkHook runs after the mutation and logic hook, and can be used to link the state machine to other state machines in the same database transaction
func TenantPSMLinkHook[
	SE TenantPSMEvent,
	DK psm.IKeyset,
	DIE psm.IInnerEvent,
](
	linkDestination psm.LinkDestination[DK, DIE],
	cb func(
		context.Context,
		*TenantState,
		SE,
		func(DK, DIE),
	) error) psm.TransitionHook[
	*TenantKeys,    // implements psm.IKeyset
	*TenantState,   // implements psm.IState
	TenantStatus,   // implements psm.IStatusEnum
	*TenantData,    // implements psm.IStateData
	*TenantEvent,   // implements psm.IEvent
	TenantPSMEvent, // implements psm.IInnerEvent
] {
	eventType := (*new(SE)).PSMEventKey()
	wrapped := func(ctx context.Context, tx sqrlx.Transaction, state *TenantState, event SE, add func(DK, DIE)) error {
		return cb(ctx, state, event, add)
	}
	return psm.TransitionHook[
		*TenantKeys,    // implements psm.IKeyset
		*TenantState,   // implements psm.IState
		TenantStatus,   // implements psm.IStatusEnum
		*TenantData,    // implements psm.IStateData
		*TenantEvent,   // implements psm.IEvent
		TenantPSMEvent, // implements psm.IInnerEvent
	]{
		Callback: func(ctx context.Context, tx sqrlx.Transaction, baton TenantPSMFullBaton, state *TenantState, event *TenantEvent) error {
			return psm.RunLinkHook(ctx, linkDestination, wrapped, tx, state, event)
		},
		EventType:   eventType,
		RunOnFollow: false,
	}
}

// TenantPSMLinkDBHook like LinkHook, but has access to the current transaction for reads only (not enforced), use in place of controller logic to look up existing state.
func TenantPSMLinkDBHook[
	SE TenantPSMEvent,
	DK psm.IKeyset,
	DIE psm.IInnerEvent,
](
	linkDestination psm.LinkDestination[DK, DIE],
	cb func(
		context.Context,
		sqrlx.Transaction,
		*TenantState,
		SE,
		func(DK, DIE),
	) error) psm.TransitionHook[
	*TenantKeys,    // implements psm.IKeyset
	*TenantState,   // implements psm.IState
	TenantStatus,   // implements psm.IStatusEnum
	*TenantData,    // implements psm.IStateData
	*TenantEvent,   // implements psm.IEvent
	TenantPSMEvent, // implements psm.IInnerEvent
] {
	eventType := (*new(SE)).PSMEventKey()
	return psm.TransitionHook[
		*TenantKeys,    // implements psm.IKeyset
		*TenantState,   // implements psm.IState
		TenantStatus,   // implements psm.IStatusEnum
		*TenantData,    // implements psm.IStateData
		*TenantEvent,   // implements psm.IEvent
		TenantPSMEvent, // implements psm.IInnerEvent
	]{
		Callback: func(ctx context.Context, tx sqrlx.Transaction, baton TenantPSMFullBaton, state *TenantState, event *TenantEvent) error {
			return psm.RunLinkHook(ctx, linkDestination, cb, tx, state, event)
		},
		EventType:   eventType,
		RunOnFollow: false,
	}
}

// TenantPSMGeneralLogicHook runs once per transition at the state-machine level regardless of which transition / event is being processed. It runs exactly once per transition, with the state object in the final state after the transition but prior to processing any further events. Chained events are added to the *end* of the event queue for the transaction, and side effects are published (as always) when the transaction is committed. The function MUST be pure, i.e. It MUST NOT produce any side-effects outside of the HookBaton, and MUST NOT modify the state.
func TenantPSMGeneralLogicHook(
	cb func(
		context.Context,
		TenantPSMHookBaton,
		*TenantState,
		*TenantEvent,
	) error) psm.GeneralEventHook[
	*TenantKeys,    // implements psm.IKeyset
	*TenantState,   // implements psm.IState
	TenantStatus,   // implements psm.IStatusEnum
	*TenantData,    // implements psm.IStateData
	*TenantEvent,   // implements psm.IEvent
	TenantPSMEvent, // implements psm.IInnerEvent
] {
	return psm.GeneralEventHook[
		*TenantKeys,    // implements psm.IKeyset
		*TenantState,   // implements psm.IState
		TenantStatus,   // implements psm.IStatusEnum
		*TenantData,    // implements psm.IStateData
		*TenantEvent,   // implements psm.IEvent
		TenantPSMEvent, // implements psm.IInnerEvent
	]{
		Callback: func(
			ctx context.Context,
			tx sqrlx.Transaction,
			baton TenantPSMFullBaton,
			state *TenantState,
			event *TenantEvent,
		) error {
			return cb(ctx, baton, state, event)
		},
		RunOnFollow: false,
	}
}

// TenantPSMGeneralStateDataHook runs at the state-machine level regardless of which transition / event is being processed. It runs at-least once before committing a database transaction after multiple transitions are complete. This hook has access only to the final state after the transitions and is used to update other tables based on the resulting state. It MUST be idempotent, it may be called after injecting externally-held state data.
func TenantPSMGeneralStateDataHook(
	cb func(
		context.Context,
		sqrlx.Transaction,
		*TenantState,
	) error) psm.GeneralStateHook[
	*TenantKeys,    // implements psm.IKeyset
	*TenantState,   // implements psm.IState
	TenantStatus,   // implements psm.IStatusEnum
	*TenantData,    // implements psm.IStateData
	*TenantEvent,   // implements psm.IEvent
	TenantPSMEvent, // implements psm.IInnerEvent
] {
	return psm.GeneralStateHook[
		*TenantKeys,    // implements psm.IKeyset
		*TenantState,   // implements psm.IState
		TenantStatus,   // implements psm.IStatusEnum
		*TenantData,    // implements psm.IStateData
		*TenantEvent,   // implements psm.IEvent
		TenantPSMEvent, // implements psm.IInnerEvent
	]{
		Callback: func(
			ctx context.Context,
			tx sqrlx.Transaction,
			baton TenantPSMFullBaton,
			state *TenantState,
		) error {
			return cb(ctx, tx, state)
		},
		RunOnFollow: true,
	}
}

// TenantPSMGeneralEventDataHook runs after each transition at the state-machine level regardless of which transition / event is being processed. It runs exactly once per transition, before any other events are processed. The presence of this hook type prevents (future) transaction optimizations, so should be used sparingly.
func TenantPSMGeneralEventDataHook(
	cb func(
		context.Context,
		sqrlx.Transaction,
		*TenantState,
		*TenantEvent,
	) error) psm.GeneralEventHook[
	*TenantKeys,    // implements psm.IKeyset
	*TenantState,   // implements psm.IState
	TenantStatus,   // implements psm.IStatusEnum
	*TenantData,    // implements psm.IStateData
	*TenantEvent,   // implements psm.IEvent
	TenantPSMEvent, // implements psm.IInnerEvent
] {
	return psm.GeneralEventHook[
		*TenantKeys,    // implements psm.IKeyset
		*TenantState,   // implements psm.IState
		TenantStatus,   // implements psm.IStatusEnum
		*TenantData,    // implements psm.IStateData
		*TenantEvent,   // implements psm.IEvent
		TenantPSMEvent, // implements psm.IInnerEvent
	]{
		Callback: func(
			ctx context.Context,
			tx sqrlx.Transaction,
			baton TenantPSMFullBaton,
			state *TenantState,
			event *TenantEvent,
		) error {
			return cb(ctx, tx, state, event)
		},
		RunOnFollow: true,
	}
}

// TenantPSMEventPublishHook  EventPublishHook runs for each transition, at least once before committing a database transaction after multiple transitions are complete. It should publish a derived version of the event using the publisher.
func TenantPSMEventPublishHook(
	cb func(
		context.Context,
		psm.Publisher,
		*TenantState,
		*TenantEvent,
	) error) psm.GeneralEventHook[
	*TenantKeys,    // implements psm.IKeyset
	*TenantState,   // implements psm.IState
	TenantStatus,   // implements psm.IStatusEnum
	*TenantData,    // implements psm.IStateData
	*TenantEvent,   // implements psm.IEvent
	TenantPSMEvent, // implements psm.IInnerEvent
] {
	return psm.GeneralEventHook[
		*TenantKeys,    // implements psm.IKeyset
		*TenantState,   // implements psm.IState
		TenantStatus,   // implements psm.IStatusEnum
		*TenantData,    // implements psm.IStateData
		*TenantEvent,   // implements psm.IEvent
		TenantPSMEvent, // implements psm.IInnerEvent
	]{
		Callback: func(
			ctx context.Context,
			tx sqrlx.Transaction,
			baton TenantPSMFullBaton,
			state *TenantState,
			event *TenantEvent,
		) error {
			return cb(ctx, baton, state, event)
		},
		RunOnFollow: false,
	}
}

// TenantPSMUpsertPublishHook runs for each transition, at least once before committing a database transaction after multiple transitions are complete. It should publish a derived version of the event using the publisher.
func TenantPSMUpsertPublishHook(
	cb func(
		context.Context,
		psm.Publisher,
		*TenantState,
	) error) psm.GeneralStateHook[
	*TenantKeys,    // implements psm.IKeyset
	*TenantState,   // implements psm.IState
	TenantStatus,   // implements psm.IStatusEnum
	*TenantData,    // implements psm.IStateData
	*TenantEvent,   // implements psm.IEvent
	TenantPSMEvent, // implements psm.IInnerEvent
] {
	return psm.GeneralStateHook[
		*TenantKeys,    // implements psm.IKeyset
		*TenantState,   // implements psm.IState
		TenantStatus,   // implements psm.IStatusEnum
		*TenantData,    // implements psm.IStateData
		*TenantEvent,   // implements psm.IEvent
		TenantPSMEvent, // implements psm.IInnerEvent
	]{
		Callback: func(
			ctx context.Context,
			tx sqrlx.Transaction,
			baton TenantPSMFullBaton,
			state *TenantState,
		) error {
			return cb(ctx, baton, state)
		},
		RunOnFollow: false,
	}
}

func (event *TenantEvent) EventPublishMetadata() *psm_j5pb.EventPublishMetadata {
	tenantKeys := make([]*psm_j5pb.EventTenant, 0)
	return &psm_j5pb.EventPublishMetadata{
		EventId:   event.Metadata.EventId,
		Sequence:  event.Metadata.Sequence,
		Timestamp: event.Metadata.Timestamp,
		Cause:     event.Metadata.Cause,
		Auth: &psm_j5pb.PublishAuth{
			TenantKeys: tenantKeys,
		},
	}
}
